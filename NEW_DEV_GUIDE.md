# Руководство для новых разработчиков Unlimotion

Этот документ собирает нетривиальные подходы в коде и архитектуре, которые могут быть неочевидны при первом знакомстве с проектом.

## Граф задач с несколькими родителями
- **Модель задачи допускает несколько родителей и блокировок.** У `TaskItem` одновременно есть списки `ParentTasks`, `ContainsTasks`, `BlocksTasks` и `BlockedByTasks`, причём `IsCompleted` трёхзначный (`true`/`false`/`null`), что позволяет создавать графы задач, а не дерево, и трактовать архивированные задачи как «не блокирующие».【F:src/Unlimotion.Domain/TaskItem.cs†L6-L28】
- **Операции менеджера возвращают весь набор затронутых задач.** Методы `TaskTreeManager` (добавление, удаление связей, пересчёт доступности) возвращают списки обновлённых элементов, чтобы UI мог массово обновить кеш без повторных загрузок. Это важно при работе с графом, где одна модификация затрагивает родителей и блокируемые узлы.【F:src/Unlimotion.TaskTreeManager/TaskTreeManager.cs†L663-L692】

## Авто-пересчёт доступности с ретраями Polly
- **Все публичные операции обёрнуты в `IsCompletedAsync` с политикой повторов Polly.** Любая команда над графом исполняется с повторами до 2 минут с шагом 1 секунда, иначе выбрасывается `TimeoutException`. Это позволяет стабильно работать с файловым/сетевым хранилищем, где запись может временно провалиться, но повторы скрыты внутри домена.【F:src/Unlimotion.TaskTreeManager/TaskTreeManager.cs†L643-L660】
- **Пересчёт доступности централизован.** `CalculateAndUpdateAvailability` сначала пересчитывает текущую задачу, затем всех аффектированных родителей и блокируемых задач, избегая реактивных вычислений во ViewModel. Поле `UnlockedDateTime` тоже обновляется там, поэтому внешние слои только отображают уже вычисленное состояние.【F:src/Unlimotion.TaskTreeManager/TaskTreeManager.cs†L663-L692】【F:src/Unlimotion.TaskTreeManager/TaskTreeManager.cs†L694-L720】

## Единое хранилище и миграции на лету
- **`UnifiedTaskStorage` объединяет доменную логику и ViewModel-кеш.** При инициализации оно запускает миграции, поднимает все задачи в `SourceCache` и подписывается на события `IStorage`. Любая запись/удаление в хранилище (включая внешние) транслируется в UI через `TaskStorageOnUpdating`, что делает поведение одинаковым для файлового и серверного режимов.【F:src/Unlimotion/UnifiedTaskStorage.cs†L14-L124】【F:src/Unlimotion/UnifiedTaskStorage.cs†L236-L282】
- **Миграции происходят прямо в клиенте.** `MigrateReverseLinks` достраивает обратные ссылки (родители/блокировки) в файловом хранилище, а `MigrateIsCanBeCompleted` однократно пересчитывает новое поле доступности и кладёт отчёт рядом с данными. Это позволяет выпускать новые версии без отдельного скрипта или сервера миграций.【F:src/Unlimotion/UnifiedTaskStorage.cs†L198-L234】

## Файловое хранилище «файл на задачу» с самоисцелением
- **Каждая задача хранится отдельным JSON-файлом и кэшируется в памяти.** Перед сохранением используется `CompareLogic` для пропуска неизменённых записей, а идентификатор генерируется и сразу добавляется в список игнорирования для `FileDbWatcher`, чтобы не ловить собственное событие изменения.【F:src/Unlimotion/FileStorage.cs†L18-L92】
- **Чтение пытается восстанавливать повреждённые файлы.** `JsonRepairingReader.DeserializeWithRepair` используется при загрузке, а пустые/битые файлы удаляются, чтобы не тормозить загрузку всех задач. Благодаря этому клиент самочинно правит пользовательское хранилище без ручного вмешательства.【F:src/Unlimotion/FileStorage.cs†L117-L170】

## Динамическая регистрация режимов хранения через сервис-локатор
- **Переключение между файлом и сервером делается в рантайме.** `TaskStorages.RegisterStorage` использует сервис-локатор Splat для замены `ITaskStorage` и создания нужного `TaskTreeManager`. Предыдущий storage отключается, а команды ViewModel (подключение, миграция, бэкап, git-операции) перепривязываются при запуске приложения через `SetSettingsCommands`. Это нетипичный путь по сравнению с статической DI-конфигурацией и важен для понимания времени жизни объектов.【F:src/Unlimotion/TaskStorages.cs†L16-L186】

## Нестандартное использование технологий и пакетов
- **ServiceStack и SignalR работают параллельно в одном хосте поверх RavenDB.** В `Startup` регистрируется RavenDB, добавляется SignalR-хаб `ChatHub`, после чего в том же пайплайне включается `ServiceStack` через `UseServiceStack`. Это означает, что HTTP-конвейер совмещает RPC/REST от ServiceStack и WebSocket-уведомления SignalR, а поведение middleware зависит от порядка вызовов.【F:src/Unlimotion.Server/Startup.cs†L23-L61】
- **LibGit2Sharp управляется через Quartz и Splat для фонового бэкапа.** В `TaskStorages.SetSettingsCommands` флаги и интервалы бэкапа из UI подписываются через ReactiveUI на изменение настроек, а триггеры `Quartz` пересобираются на лету. Команды клон/пул/пуш вызывают `IRemoteBackupService`, которая реализована на `LibGit2Sharp` и временно выключает файловый `IDatabaseWatcher`, чтобы git-операции не создавали лишние события синхронизации. Таким образом, файловое хранилище, шедулер и git-клиент работают согласованно, хотя обычно такие слои разделяют.【F:src/Unlimotion/TaskStorages.cs†L20-L146】【F:src/Unlimotion/Services/BackupViaGitService.cs†L15-L188】

## Клиентские особенности и необычные комбинации технологий
- **Опциональный Live.Avalonia и отключение встроенной валидации Avalonia.** В десктопной инициализации при подключённом дебаггере можно включить `LiveViewHost` для хот-релоада XAML (#define `LIVE`), а штатный `DataAnnotationsValidationPlugin` удаляется из `BindingPlugins`, чтобы не дублировать ошибки вместе с CommunityToolkit. Это поведение скрыто в `App.OnFrameworkInitializationCompleted` и влияет на диагностику привязок и UX форм.【F:src/Unlimotion/App.axaml.cs†L1-L116】
- **Настройки как изменяемый JSON-конфиг через WritableJsonConfiguration + Splat.** `App.Init` создаёт файл конфигурации через `WritableJsonConfigurationFabric`, сразу регистрирует его в `Locator` и заполняет дефолты для Git/TaskStorage. Затем же на лету регистрируется `StdSchedulerFactory` и сервисы уведомлений/резервных копий. Итог: конфиг — часть состояния клиента, его можно переписать из UI, а фоновый шедулер и сервисы автоматически подхватят новые значения без отдельного DI-слоя.【F:src/Unlimotion/App.axaml.cs†L123-L210】
- **Графовый режим читает состояние из главной VM через сервис-локатор.** `GraphViewModel` резолвит `MainWindowViewModel` из Splat и проксирует флаги фильтров (архив/желанность) напрямую, а списки задач и эмодзи-фильтров ему выдаёт сама главная VM. Это нетипичная двухсторонняя связь (VM -> Locator -> VM), но она гарантирует, что граф и дерево показывают один и тот же набор фильтров без отдельного состояния.【F:src/Unlimotion.ViewModel/GraphViewModel.cs†L1-L31】【F:src/Unlimotion.ViewModel/MainWindowViewModel.cs†L196-L309】【F:src/Unlimotion.ViewModel/MainWindowViewModel.cs†L820-L845】
- **Динамическое построение эмодзи-фильтров и графа через DynamicData.** В `Connect` коллекция задач группируется по `Emoji`, откуда автоматически собираются два набора фильтров (включить/исключить) и передаются в `Graph`. Тот же поток change-set’ов применяет цепочки фильтров (архив/желанность/эмодзи/поиск), создаёт `TaskWrapperViewModel` с кастомными действиями для навигации по графу и обновляет выделение при изменении списка. Это связывает UI-фильтры, графовый режим и дерево задач без ручной синхронизации списков.【F:src/Unlimotion.ViewModel/MainWindowViewModel.cs†L196-L356】【F:src/Unlimotion.ViewModel/MainWindowViewModel.cs†L820-L845】

### MVVM и нетипичная реактивность
- **INotifyPropertyChanged внедряется через Fody вместо базового класса.** ViewModel’и помечены атрибутом `AddINotifyPropertyChangedInterface` и наследуются от `DisposableList`, а не от `ReactiveObject`. Fody вшивает уведомления, после чего ReactiveUI использует `WhenAnyValue` и `ReactiveCommand`, при этом подписки сразу добавляются в общий `DisposableList` через `.AddToDispose(this)` для автоматической очистки.【F:src/Unlimotion.ViewModel/MainWindowViewModel.cs†L17-L57】【F:src/Unlimotion.ViewModel/TaskItemViewModel.cs†L21-L68】【F:src/Unlimotion.ViewModel/TaskWrapperViewModel.cs†L69-L118】
- **Сохранение задачи триггерится из наблюдения за изменениями с пропусками и троттлингом.** `TaskItemViewModel` собирает событие `PropertyChanged` в реактивный поток, фильтрует только важные поля, а после инициализации применяет `Throttle` (10 секунд по умолчанию). Это устраняет всплески записей в хранилище при наборе текста или быстром изменении дат, но требует помнить, что `SaveItemCommand` срабатывает не мгновенно.【F:src/Unlimotion.ViewModel/TaskItemViewModel.cs†L200-L237】【F:src/Unlimotion.ViewModel/TaskItemViewModel.cs†L43-L139】
- **Коллекции связей синхронизируются через DynamicData вместо ручного обновления.** Списки родителей/детей/блокировок хранятся как `ObservableCollection<string>` с идентификаторами, а визуальное представление строится подпиской на общий `ITaskStorage.Tasks.Connect()` с фильтром по этим ID. Вся линковка обновляется реактивно при любом изменении хранилища, поэтому в UI нет отдельных методов «добавить в список» — достаточно изменить ObservableCollection идентификаторов.【F:src/Unlimotion.ViewModel/TaskItemViewModel.cs†L54-L129】
- **Дерево задач строится лениво и реактивно.** `TaskWrapperViewModel` не хранит подзадачи заранее: первый доступ к `SubTasks` запускает `ChildSelector` и цепочку DynamicData `Transform/Sort/Bind`, на которую накладываются фильтры и сортировка, переданные снаружи. Это позволяет переиспользовать один и тот же wrapper для дерева, графа и произвольных списков, меняя только набор Observable-потоков.【F:src/Unlimotion.ViewModel/TaskWrapperViewModel.cs†L69-L124】

## Как использовать эту информацию
- При добавлении новых операций в `TaskTreeManager` не забывайте возвращать все затронутые задачи и оборачивать логику в `IsCompletedAsync`, чтобы UI и ретраи работали согласованно.
- Любые изменения формата `TaskItem` должны сопровождаться миграцией внутри `UnifiedTaskStorage`, иначе существующие файловые базы останутся в старом виде.
- При работе с файловым режимом учитывайте, что внешнее изменение файлов придёт через `TaskStorageOnUpdating`; избегайте прямых манипуляций с кешем `Tasks`.
